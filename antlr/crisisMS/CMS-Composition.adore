// 

//CMS => Crisis Management System 
//coordinatorSystem => User Interface for Coordinator 

//4.2.1 Not finished
//I assume that the system deals with only one Crisis at once.

//Use Case 1: Resolve Crisis 
//The initial scenario is defined without loops.
//They are expressed as evolutions : We no more work on a ressource but on a set of ressources.

//Witness places a call to the crisis centre, where it is answered by a Coordinator. 
//1. Coordinator captures witness report (UC 2). 
//2. System recommends to Coordinator the missions that are to be executed based on the current information about the crisis and resources. 
//3. Coordinator selects one or more missions recommended by the system. 
//Perso : 1) We define the initial scenario with one mission. An evolution adds the possibility for the coordinator to select a set of missions.
//For each mission in parallel: 
//4. For each internal resource required by a selected mission, System assigns an internal resource (UC 3). 
//5. For each external resource required by a selected mission, System requests an external resource (UC 4). 
//Perso : the following steps 6-11 are taken into account in manageRessource
  //6. Resource notiﬁes System of arrival at mission location. 
  //7. Resource executes the mission (UC 5). 
  //8. Resource notiﬁes System of departure from mission location. 
  //9. In parallel to steps 6-8, Coordinator receives updates on the mission status from System. 
  //10. In parallel to steps 6-8, System informs Resource of relevant changes to mission / crisis information. 
  //11. Resource submits the ﬁnal mission report to System. 
//Perso : a dedicated service is defined for the following : cms::setNewCrisisInformation, 
   //12. In parallel to steps 4-8, Coordinator receives new information about the crisis from System. 
//13. Coordinator closes the ﬁle for the crisis resolution. 
//Use case ends in success. 
orchestration cms::resolveStop {
  variables {
    
    mission* as mission;
    selectedMission as mission;
    internalRessource as ressource;
    externalRessource as ressource;
  }
  activities {
    a0. receive();
    a1. cms::witnessReportCapture();
    a2. mission* := cms::missionsToDo();
    a3. selectedMission := coordinatorSystem::select(mission*);
    a45. cms::dealWithOneMission(selectedMission);
    a13. coordinatorSystem::close();
    a6.reply();
    o. reply();
  }
  relations { a0 < a1; a1 < a2; a2<a3; a3<a45 ; a45<a13; a13<a6;fail(a1,'infoDoesNotMatch') < o;}
}

orchestration cms::resolveStopLog {
  variables {
    
    mission* as mission;
    selectedMission as mission;
    internalRessource as ressource;
    externalRessource as ressource;
    isLogged as boolean ;
    a as boolean;
  }
  activities {
    a0. receive();
    a1. cms::witnessReportCapture();
    a2. mission* := cms::missionsToDo();
    a3. selectedMission := coordinatorSystem::select(mission*);
    a45. cms::dealWithOneMission(selectedMission);
    a13. coordinatorSystem::close();
    a6.reply();
    o. reply();
    logTest. isLogged := authentification100::isLogged(coordinatorSystem);
    authent. a := authentification100::authenticates(coordinatorSystem); //Uc 10???
    e. throw('accessDenied' as string);
  }
  relations { a0 < a1; a1 < a2; a2<a3; a3<a45 ; a45<a13; a13<a6;fail(a1,'infoDoesNotMatch') < o;
              a0 < logTest; logTest<a1 when isLogged ; 
              logTest < authent when !isLogged; 
              authent<a1 when a;
	      authent<e when !a; }
}

orchestration cms::dealWithOneMission {
  variables {
    
    m as mission;
    internalRessource as ressource;
    externalRessource as ressource;
  }
  activities {
    a0. m := receive();
     //System assigns internal Ressource(s)
       a4a. internalRessource := getInternalRessources(m);
       a4a2. cms::assignInternalRessources(internalRessource,m);
       a4a3. cms::manageRessource(internalRessource,m);
      //System requests external Ressources    
       a5a. externalRessource := getExternallRessources(m);
       a5a2. cms::assignExternalRessources(externalRessource,m);
       a5a3. cms::manageRessource(externalRessource,m);  
    a6.reply();
  }
  relations { a0 <a4a ; a4a<a4a2; a4a2<a4a3; a4a3<a6; a0<a5a;a5a<a5a2;a5a2<a5a3;a5a3<a6;}
}



//From 4.2.1
//Resource notifies System of arrival at mission location.
//Resource notifies System of departure from mission location.
//Resource submits the final mission report to System.

orchestration cms::manageRessource{
  variables {
    r as ressource;
    m as mission;
  }
  activities {
    a0. (r,m) := receive();
    a1. ressourceManager::askForArrival(r,m);
    //a1a.coordinatorSystem::notify('arrived' as string,r);
    a2. ressourceManager::askForExecutionEnd(r,m);
    //a2a.coordinatorSystem::notify('endExecution'  as string,r,m);
    a11.ressourceManager::askForfinalMissionReport(r,m);
    a3. reply('true' as boolean);
  }
  relations { a0 < a1;  a1 < a2;a2<a11; a11<a3;}
}




//From 4.2.1
//10.  System informs Resource of relevant changes to mission / crisis information.
orchestration cms::setNewCrisisInformation{
  variables {
    i as crisisInformation;
    relevant as boolean;
  }
  activities {
    a0. (i) := receive();
    //a12. coordinatorSystem::notify('newInfo'  as string,i);
    a1. relevant := cms::isRelevantInformation(i);
    a10. ressourceManager::notify(i);
    r. reply();
  }
  relations { a0 < a1; a1 < a10 when relevant; a1 < r ;}
}


// 4.2.2
//Capture Witness Report 
//Use Case 2: Capture Witness Report 
//Scope: Car Crash Crisis Management System 
//1. Coordinator provides witness information1 to System as reported by the witness. 
//2. Coordinator informs System of location and type of crisis as reported by the witness. 
//In parallel to steps 2-4: 
//2a.1 System contacts PhoneCompany to verify witness information. 
//2a.2 PhoneCompany sends address/phone information to System. 
//2a.3 System validates information received from the PhoneCompany. 
//3. System provides Coordinator with a crisis-focused checklist. 
//4. Coordinator provides crisis information2 to System as reported by the witness. 
//5. System assigns an initial emergency level to the crisis and sets the crisis status to active. 
//Use case ends in success. 

orchestration cms::witnessReportCaptureCession {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    adress as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
  }
  activities {	
    a0. receive();
    a1. wi := coordinatorSystem::provideWitnessInformation();
    a2. li := coordinatorSystem::provideLocationInformation();
    a2a12. adress := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(adress,wi);
    a3. cl := cms::computeCheckList();
    a4. ci := coordinatorSystem::provideCrisisInformation(cl);
    a5. setCurrentCrisisActive(cms,ci);
    a6. reply();
    t. throw('infoDoesNotMatch' as string);

  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a6  when exact; 
              a2a3 < t when !exact;} 
}



orchestration cms::witnessReportCaptureCessionVideoSurveillance {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    adress as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    feeder as feederSystem;
  }
  activities {	
    a0. receive();
    a1. wi := coordinatorSystem::provideWitnessInformation();
    a2. li := coordinatorSystem::provideLocationInformation();
    a2a12. adress := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(adress,wi);
    a3. cl := cms::computeCheckList();
    a4. ci := coordinatorSystem::provideCrisisInformation(cl);
    a5. setCurrentCrisisActive(cms,ci);
    a6. reply();
    t. throw('infoDoesNotMatch' as string);
    a1rq. feeder := surveillanceSystem::getVideo();
    a2rq. coordinatorSystem::setVideo(feeder);
  }   
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; 
              a5<a6;a2a3<a6  when exact; 
              a2a3 < t when !exact; 
              fail(a1, 'unreachable') <a1rq  ;  
              fail(a2, 'unreachable') <a1rq  ;
               a2rq<<a4;a2rq<<a2a3;
  	       a1rq< a2rq ;} 
}

orchestration cms::witnessReportCaptureCessionVideoSurveillanceOnRequest {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    adress as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    ok as boolean;
    feeder as feederSystem;
  }
  activities {	
    a0. receive();
    a1. wi := coordinatorSystem::provideWitnessInformation();
    a2. li := coordinatorSystem::provideLocationInformation();
    a2a12. adress := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(adress,wi);
    a3. cl := cms::computeCheckList();
    a4. ci := coordinatorSystem::provideCrisisInformation(cl);
    a5. setCurrentCrisisActive(cms,ci);
    a6. reply();
    t. throw('infoDoesNotMatch' as string);
    a1rq. feeder := surveillanceSystem::getVideo();
    a2rq. coordinatorSystem::setVideo(feeder);
    a1orq. ok :=  coordinatorSystem::isFakeCrisis() ;
  }   
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; 
              a5<a6;a2a3<a6  when exact; 
              a2a3 < t when !exact; 
              fail(a1, 'unreachable') <a1rq  ;  
              fail(a2, 'unreachable') <a1rq  ;
               a2rq<<a4;a2rq<<a2a3;
  	       a1rq< a2rq ;
               a2 < a1orq; a1orq<a2a3  when ok;  a1orq<a4 when ok; a1orq<a2a3  when ok;    } 
}

orchestration cms::witnessReportCaptureCessionVideoSurveillanceOnRequestContinue {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    adress as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    ok as boolean;
    feeder as feederSystem;
  }
  activities {	
    a0. receive();
    a1. wi := coordinatorSystem::provideWitnessInformation();
    a2. li := coordinatorSystem::provideLocationInformation();
    a2a12. adress := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(adress,wi);
    a3. cl := cms::computeCheckList();
    a4. ci := coordinatorSystem::provideCrisisInformation(cl);
    a5. setCurrentCrisisActive(cms,ci);
    a6. reply();
    t. throw('infoDoesNotMatch' as string);
    a1rq. feeder := surveillanceSystem::getVideo();
    a2rq. coordinatorSystem::setVideo(feeder);
    a1orq. ok :=  coordinatorSystem::isFakeCrisis() ;
  }   
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; 
              a5<a6;a2a3<a6  when exact; 
              a2a3 < t when !exact; 
              fail(a1, 'unreachable') <a1rq  ;  
              fail(a2, 'unreachable') <a1rq  ;
               a2rq<<a4;a2rq<<a2a3;
  	       a1rq< a2rq ;
               a2 < a1orq; a1orq<a2a3  when ok;  a1orq<a4 when ok; a1orq<a2a3  when ok;  
               fail(a1,'unreachable')<a6; 
fail(a2,'unreachable')<a6; 
fail(a3,'unreachable')<a6; 
fail(a4,'unreachable')<a6; 
fail(a5,'unreachable')<a6; 
fail(a2a12,'unreachable')<a6; 
fail(a2a3,'unreachable')<a6; 
 } 
}



// 4.2.2
//Main Success Scenario: 
//System selects an appropriate CMSEmployee based on the mission type, the emergency level, location and 
//requested expertise. 
//TODO/Perso : We have to take care of the following requirements in an evolution.
// In very urgent cases, steps 1 and 2 can be performed for several CMSEmployees concur- 
//rently, until one of the contacted employees accepts the mission. 
//1. System sends CMSEmployee mission information. 
//2. CMSEmployee informs System that he accepts the mission. 
//Use case ends in success.
orchestration cms::assignInternalResource {
  variables {
    m as mission;
    accept as boolean;
    cmsEmployee as employee;
  }
  activities {	
    a0. m := receive();
    a1. cmsEmployee := cms::selectEmployee(m);
    a2. accept := cmsEmployee::askFor(m);
    a6. reply(cmsEmployee);

  } 
  relations { a0 < a1; a1 < a2; a2<a6 ; } 
}


// 4.2.2
/* 4.2.4 Request External Resource */
/* Use Case 4: Request External Resource */
/* Scope: Car Crash Crisis Management System */
/* Primary Actor: Coordinator */
/* Secondary Actor: ExternalResourceSystem (ERS) */
/* Intention: The System requests a mission from an external resource, such as a fire station, police station or external */
/* ambulance service. */
/* Main Success Scenario: */
/* 1. System sends mission request to ERS, along with mission-specific information1. */
/* 2. ERS informs System that request can be processed. */
/* Use case ends in success. */
//Perso : Following extensions are managed by the return allocated ressource or an error
//2a. ERS notifies System that it partially approves request for resources. Use case ends in degraded success.
//2a. ERS notifies System that it partially approves request for resources. Use case ends in degraded success.
orchestration cms::assignExternalResource {
  variables {
    m as mission;
    eS as externalRessource;
    allocatedRessource as externalRessource;
  }
  activities {	
    a0. m := receive();
    a1. allocatedRessource := eRS::request(m);
    a2. reply(allocatedRessource);

  } 
  relations { a0 < a1; a1 < a2 ; } 
}


//4.2.7 part 3
orchestration cms::setNewVictimInformation {
  variables {
    info as information;
    hostpitalInfo as information;
  }
  activities {	
    a0. info := receive();
   //System requests victim’s medical history information "from all"connected HospitalResourceSystems. 
   a1. hostpitalInfo := hospitalResourceSystems::getInfo(info);
   a2. reply(hostpitalInfo);
  } 
  relations { a0 < a1; a1 < a2; } 
 } 



//-----------------------------------------------


//4.2.5
//n'importequoi a revoir totalement
/* Use Case 6: Execute SuperObserver Mission */
/* Scope: Car Crash Crisis Management System */
/* Primary Actor: SuperObserver */
/* Secondary Actor: None */
/* Intention: The intention of the SuperObserver is to observe the situation at the crisis site to be able to order */
/* appropriate missions. */
/* 19 */
/* Main Success Scenario: */
/* SuperObserver is at the crisis location. */
/* 1. System sends a crisis-specific checklist to SuperObserver. */
/* 2. SuperObserver feeds System with crisis information. */
/* 3. System suggests crisis-specific missions to SuperObserver. */
/* Steps 4-8 is repeated as many times as needed. */
/* 4. SuperObserver notifies System of the type of mission he wants to create. */
/* 5. System sends a mission-specific information request to SuperObserver. */
/* 6. SuperObserver sends mission-specific information1 to System. */
/* 7. System acknowledges the mission creation to SuperObserver. */
/* 8. System informs SuperObserver that mission was completed successfully. */
/* 9. SuperObserver judges that his presence is no longer needed at the crisis location. */
/* Use case ends in success. */
orchestration superObserver::executeMission {
  variables {
    m as mission;
    mission* as mission;
    cL as checkList;
    ci as crisisInformation;
  }
  activities {	
    a0. m := receive();
    a1. cL := cms::getCrisisSpecificCheckList(m);
    a2. ci := superObserver::feed(cL);
    a2c. cms::setNewCrisisInformation(ci);
    // end set
    //System suggests crisis-speciﬁc missions to SuperObserver
    a3. mission* := cms::missionsToDo();
    a3a. superObserver::suggest(mission*);
   //SuperObserver notiﬁes System of the type of mission he wants to create...step 4 to 8
    a89. superObserver::manageMissions();
   //SuperObserver judges that his presence is no longer needed at the crisis location. 
    a9. ressourceManager::setExecutionEnd(m,superObserver);
  } 
  relations { a0 < a1; a1 < a2; a2<a2c; a2c<a3;a3<a89;a89<a9; } 
} 

//4. SuperObserver notifies System of the type of mission he wants to create.
//5. System sends a mission-specific information request to SuperObserver.
//6. SuperObserver sends mission-specific information1 to System.
//7. System acknowledges the mission creation to SuperObserver.
//8. System informs SuperObserver that mission was completed successfully
//Perso : il faudrait factoriser le create mission....
//Je hais cette orchestration...n'importe quoi....
orchestration superObserver::manageMissions {
  variables {
    mission as mission;
    cL as checkList;
    ci as crisisInformation;
    again as boolean;
  }
  activities {	
    a0.  receive();
    a4. mission := whichMission();
    a5. request := cms::getMissionSpecificRequest(mission);
    a6. mission := superObserver::fillRequest(request);
    a7. mission := cms::createMission(mission);
    a8. cms::manageMission(mission);
    stop. again := askForMissionCreation();
    loop. superObserver::manageMissions();
    end. reply();

  } 
  relations { a0 < a4; a4 < a5; a5<a6; a6<a7;a7<a8;a8<stop;stop<loop when again; stop<end when !again; } 
}


//4.2.7 Execute Rescue Mission
//Use Case 7: Execute Rescue Mission
//Scope: Car Crash Crisis Management System
//Primary Actor: FirstAidWorker
//Secondary Actor: HospitalRS
//Intention: The intention of the FirstAidWorker is to accept and then execute a rescue mission that involves transporting a victim to the most appropriate hospital.
//Main Success Scenario:
//FirstAidWorker is at the crisis location.
//1. FirstAidWorker transmits injury information of victim to System.
//Steps 2 and 3 are optional.
//2. FirstAidWorker determines victim’s identity and communicates it to System.
//3. System requests victim’s medical history information from all connected HospitalResourceSystems.
//FirstAidWorker administers first aid procedures to victim.
//4. System instructs FirstAidWorker to bring the victim to the most appropriate hospital.
//5. FirstAidWorker notifies System that he is leaving the crisis site.
//6. FirstAidWorker notifies System that he has dropped off the victim at the hospital.
//7. FirstAidWorker informs System that he has completed his mission.
//Use case ends in success.
//Perso : probablement ajouter pkys de setNewCrisisInformation
//Perso : verfier les types... ca ne doit pas bien aller

//Distinguer IHM et Service????
orchestration workerSystem::executeMission {
  variables {
    m as mission;
    mission* as mission;
    hospital as string;
    q as question;
    ci as crisisInformation;
    info as information;
    b as boolean;
    medicalHistory as information;
  }
  activities {	
    a0. m := receive();
    //FirstAidWorker transmits injury information of victim to System. 
    a1a. ci := workerSystem::getVictimInjuryInformation();
    a1b. cms::setNewCrisisInformation(ci);
    //2. FirstAidWorker determines victim’s identity and communicates it to System. 
    a2a.  (b,info) := workerSystem::getVictimInformation();
    a2b. cms::setNewVictimInformation(info);
    //3. System requests victim’s medical history information from all connected HospitalResourceSystems.
    a3. medicalHistory := cms::getMedicalHistoryInformation(info);
    a4. hospital :=  cms::hospitalToGo(ci);
    a4a. workerSystem::setHospitalToGo(hospital);
    a5. workerSystem::confirmLeaving();
    a6. workerSystem::confirmDropping();
    a7. workerSystem::confirmMissionCompleted();
    a8. reply();
  } 
  relations { a0 < a1a; a1a < a1b; a0<a2a; a2a<a2b when b ;a2b<a3;
    a1b<a4;a4<a4a;a4a<a5; a5< a6; a6 < a7; a7<a8; } 
}
