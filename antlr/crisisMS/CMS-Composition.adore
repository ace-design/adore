/*
// 

//CMS => Crisis Management System 
//coordinatorSystem => User Interface for Coordinator 

//4.2.1 Not finished
//I assume that the system deals with only one Crisis at once.

//Use Case 1: Resolve Crisis 
//The initial scenario is defined without loops.
//They are expressed as evolutions : We no more work on a ressource but on a set of ressources.

//Witness places a call to the crisis centre, where it is answered by a Coordinator. 
//1. Coordinator captures witness report (UC 2). 
//2. System recommends to Coordinator the missions that are to be executed based on the current information about the crisis and resources. 
//3. Coordinator selects one or more missions recommended by the system. 
//Perso : 1) We define the initial scenario with one mission. An evolution adds the possibility for the coordinator to select a set of missions.
//For each mission in parallel: 
//4. For each internal resource required by a selected mission, System assigns an internal resource (UC 3). 
//5. For each external resource required by a selected mission, System requests an external resource (UC 4). 
//Perso : the following steps 6-11 are taken into account in manageRessource
  //6. Resource notiﬁes System of arrival at mission location. 
  //7. Resource executes the mission (UC 5). 
  //8. Resource notiﬁes System of departure from mission location. 
  //9. In parallel to steps 6-8, Coordinator receives updates on the mission status from System. 
  //10. In parallel to steps 6-8, System informs Resource of relevant changes to mission / crisis information. 
  //11. Resource submits the ﬁnal mission report to System. 
//Perso : a dedicated service is defined for the following : cms::setNewCrisisInformation, 
   //12. In parallel to steps 4-8, Coordinator receives new information about the crisis from System. 
//13. Coordinator closes the ﬁle for the crisis resolution. 
//Use case ends in success. 


orchestration cms::resolve {
  variables {
    
    mission* as mission;
    selectedMission as mission;
    internalRessource as ressource;
    externalRessource as ressource;
    user as cmsEmployee;
    crisisIdentifier as string ;
  }
  activities {
    a0. (user,crisisIdentifier) := receive();
    a1. cms::witnessReportCapture(user,crisisIdentifier);
    a2. mission* := cms::missionsToDo(crisisIdentifier);
    a3. selectedMission := coordinatorSystem::select(mission*,user);
    a45. cms::dealWithOneMission(selectedMission,user,crisisIdentifier);
    a13. coordinatorSystem::close(user,crisisIdentifier);
    a6.reply();
  }
  relations { a0 < a1; a1 < a2; a2<a3; a3<a45 ; a45<a13; a13<a6;}
}


// apply log => a1;
// }

orchestration cms::resolveExt1 {
   variables {
    
    mission* as mission;
    selectedMission as mission;
    internalRessource as ressource;
    externalRessource as ressource;
    user as cmsEmployee;
    crisisIdentifier as string ;
    logged as boolean;
    auth as boolean;
  }
  activities {
    a0. (user,crisisIdentifier) := receive();
    a1. cms::witnessReportCapture(user,crisisIdentifier);
    a2. mission* := cms::missionsToDo(crisisIdentifier);
    a3. selectedMission := coordinatorSystem::select(mission*,user);
    a45. cms::dealWithOneMission(selectedMission,user,crisisIdentifier);
    a13. coordinatorSystem::close(user,crisisIdentifier);
    a6.reply();

    logTest. logged := cms::isLogged(user) ;
    authTest. auth := cms::authenticates(user) ;
    error. throw('UnauthorizedAccess' as string) ;
    nop1. nop();
    nop2. nop();
  }
  relations { 
    //a0 < a1; 
    a1 < a2; a2<a3; a3<a45 ; a45<a13; a13<a6;

    a0 < logTest ;
    logTest < nop1 when logged ;
    logTest < authTest when !logged ;
    authTest < nop2 when auth ;
    authTest < error when ! auth;
    nop1 << a1; nop2 << a1;
    a1 < a2;

}
}



orchestration cms::dealWithOneMission {
  variables {
    
    m as mission;
    internalRessource as ressource;
    externalRessource as ressource;
  }
  activities {
    a0. m := receive();
     //System assigns internal Ressource(s)
       a4a. internalRessource := getInternalRessources(m);
       a4a2. cms::assignInternalRessources(internalRessource,m);
       a4a3. cms::manageRessource(internalRessource,m);
      //System requests external Ressources    
       a5a. externalRessource := getExternalRessources(m);
       a5a2. cms::assignExternalRessources(externalRessource,m);
       a5a3. cms::manageRessource(externalRessource,m);  
    a6.reply();
  }
  relations { a0 <a4a ; a4a<a4a2; a4a2<a4a3; a4a3<a6; a0<a5a;a5a<a5a2;a5a2<a5a3;a5a3<a6;}
}

//
//To build the initial scenario
//1)
//composition    { 
//  toSet cms::resolve::selectedMission;
//  toSet  cms::dealWithOneMission::internalRessource;
//  toSet  cms::dealWithOneMission::externalRessource;
//}

*/
/* //4a. Internal resource is not available after step 4.  */
/* //4a.1 System requests an external resource instead (i.e., use case continues in parallel with step 5).  */
/* composition cms::dealWithOneMission {  */
/*  apply ressourceAvailability (ressource : 'internalRessource' , mission :'selectedMission' ) => { a4a2; a4a3} */


/*  } */

/* //5a. External resource is not available after step 5.  */
/* //5a.1 Use case continues in parallel with step 2.  */
/* composition cms::dealWithOneMission {  */
/*  apply ressourceAvailabilityDegrated (ressource : 'externalRessource') => { a5a2;a5a3 }*/
/*  } */

//TODO? : Faut ajouter le reply de maniere automatique non?
/*
orchestration cms::dealWithOneMissionExt4a5b {
  variables {
    
    m as mission;
    internalRessource as ressource;
    externalRessource as ressource;
    b2 as boolean;
    i2 as crisisInformation;
   b1 as boolean;
   r1 as ressource ;
  }
  activities {
    a0. m := receive();
     //System assigns internal Ressource(s)
       a4a. internalRessource := getInternalRessources(m);
       a4a2. cms::assignInternalRessources(internalRessource,m);
       a4a3. cms::manageRessource(internalRessource,m);
      //System requests external Ressources    
       a5a. externalRessource := getExternalRessources(m);
       a5a2. cms::assignExternalRessources(externalRessource,m);
       a5a3. cms::manageRessource(externalRessource,m);  
       a6.reply();

    availabilityTest2. b2 :=  ressourceManager::isAvailable(externalRessource);
    conta2. i2 := new('crisisInformation' as string, 'ressourceUnavailable' as string,externalRessource);
    contb2. cms::setNewCrisisInformation(i2,m);
    xor2. nop();

    availabilityTest1. b1 :=  ressourceManager::isAvailable(internalRessource);
    ask1. r1 := ressourceManager::getCorrespondingExternalRessource(internalRessource);
    ass1. cms::assignExternalRessources(r1,m);
    xor1. nop();

  }
  relations { a0 <a4a ; a4a<a4a2; a4a2<a4a3; a4a3<<xor1; a0<a5a;a5a<a5a2;a5a2<a5a3;a5a3<<xor2;

 a5a < availabilityTest2; availabilityTest2<a5a2 when b2 ;  
 availabilityTest2 < conta2 when !b2; conta2<contb2;contb2<<xor2; xor2<a6;

a4a < availabilityTest1; availabilityTest1<a4a2 when b1 ;
 availabilityTest1 < ask1 when !b1; ask1<ass1 ;  ass1<<xor1; xor1<a6;
  }
}


orchestration cms::dealWithOneMissionToSet {
  variables {
    m as mission;
    internalRessource as ressource; 
    externalRessource as ressource; 

    internalRessource* as ressource; 
    externalRessource* as ressource;
  }
  activities {
    a0. m := receive();
    //System assigns internal Ressource(s)
    a4a. internalRessource* := getInternalRessources(m);
    a4a2. cms::assignInternalRessources(internalRessource,m);
    a4a3. cms::manageRessource(internalRessource,m);
    //System requests external Ressources    
    a5a. externalRessource* := getExternallRessources(m);
    a5a2. cms::assignExternalRessources(externalRessource,m);
    a5a3. cms::manageRessource(externalRessource,m);  
    a6.reply();
  }
  relations { a0 <a4a ; a4a<a4a2; a4a2<a4a3; a4a3<a6; a0<a5a;a5a<a5a2;a5a2<a5a3;a5a3<a6;}
}

%%% DISENGAGE %%%
defPolicy(p0,forall(cms_dealWithOneMissionToSet_internalRessource,cms_dealWithOneMissionToSet_internalRessource_star),none),
  defPolicy(p1,forall(cms_dealWithOneMissionToSet_externalRessource,cms_dealWithOneMissionToSet_externalRessource_star),none),
setIteration(cms_dealWithOneMissionToSet_a4a2,p0),
setIteration(cms_dealWithOneMissionToSet_a4a3,p0),
setIteration(cms_dealWithOneMissionToSet_a5a2,p1),
setIteration(cms_dealWithOneMissionToSet_a5a3,p1),
%%% ENGAGE %%%

*/

orchestration cms::dealWithOneMissionToSetExt4a5b {
  variables {
    m as mission;
    internalRessource as ressource; 
    externalRessource as ressource; 

    internalRessource* as ressource; 
    externalRessource* as ressource;

    b2 as boolean;
    i2 as crisisInformation;
    b1 as boolean;
    r1 as ressource ;
  }
  activities {
    a0. m := receive();
    //System assigns internal Ressource(s)
    a4a. internalRessource* := getInternalRessources(m);
    a4a2. cms::assignInternalRessources(internalRessource,m);
    a4a3. cms::manageRessource(internalRessource,m);
    //System requests external Ressources    
    a5a. externalRessource* := getExternallRessources(m);
    a5a2. cms::assignExternalRessources(externalRessource,m);
    a5a3. cms::manageRessource(externalRessource,m);  
    a6.reply();

    availabilityTest2. b2 :=  ressourceManager::isAvailable(externalRessource);
    conta2. i2 := new('crisisInformation' as string, 'ressourceUnavailable' as string,externalRessource);
    contb2. cms::setNewCrisisInformation(i2,m);
    xor2. nop();

    availabilityTest1. b1 :=  ressourceManager::isAvailable(internalRessource);
    ask1. r1 := ressourceManager::getCorrespondingExternalRessource(internalRessource);
    ass1. cms::assignExternalRessources(r1,m);
    xor1. nop();

  }
  relations { 
    a0 <a4a ; a4a<a4a2; a4a2<a4a3; a4a3<<xor1; a0<a5a;a5a<a5a2;a5a2<a5a3;a5a3<<xor2;
    a5a < availabilityTest2; availabilityTest2<a5a2 when b2 ;  
    availabilityTest2 < conta2 when !b2; conta2<contb2;contb2<<xor2; xor2<a6;
    a4a < availabilityTest1; availabilityTest1<a4a2 when b1 ;
    availabilityTest1 < ask1 when !b1; ask1<ass1 ;  ass1<<xor1; xor1<a6;
  }
}

%%% DISENGAGE %%%
    defPolicy(p2,forall(cms_dealWithOneMissionToSetExt4a5b_internalRessource,cms_dealWithOneMissionToSetExt4a5b_internalRessource_star),none),
    defPolicy(p3,forall(cms_dealWithOneMissionToSetExt4a5b_externalRessource,cms_dealWithOneMissionToSetExt4a5b_externalRessource_star),none),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_a4a2,p2),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_a4a3,p2),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_availabilityTest1,p2),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_ask1,p2),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_ass1,p2),
    
    
    setIteration(cms_dealWithOneMissionToSetExt4a5b_a5a2,p3),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_a5a3,p3),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_availabilityTest2,p3),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_conta2,p3),
    setIteration(cms_dealWithOneMissionToSetExt4a5b_contb2,p3),
    
    %% cosmetic
    
    %setIteration(cms_dealWithOneMissionToSetExt4a5b_xor2,p3),
    %setIteration(cms_dealWithOneMissionToSetExt4a5b_xor1,p2),
%%% ENGAGE %%% 


  
//========================================
//========================================
//========================================

// 4.2.2
//Capture Witness Report 
//Use Case 2: Capture Witness Report 
//Scope: Car Crash Crisis Management System 
//1. Coordinator provides witness information1 to System as reported by the witness. 
//2. Coordinator informs System of location and type of crisis as reported by the witness. 
//In parallel to steps 2-4: 
//2a.1 System contacts PhoneCompany to verify witness information. 
//2a.2 PhoneCompany sends address/phone information to System. 
//2a.3 System validates information received from the PhoneCompany. 
//3. System provides Coordinator with a crisis-focused checklist. 
//4. Coordinator provides crisis information2 to System as reported by the witness. 
//5. System assigns an initial emergency level to the crisis and sets the crisis status to active. 
//Use case ends in success. 


orchestration cms::witnessReportCapture {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    user as cmsEmployee;
    crisisIdentifier as string ;
  }
  activities {	
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();

  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;} 
}

/*
//from 4.2.2
//1a,2a. The call is disconnected. The base use case terminates. 
//composition  cms::witnessReportCapture { 
//  apply unreachable(deadline : '10') =>  a1;

//}

orchestration cms::witnessReportCaptureExt1a {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    user as cmsEmployee;
    crisisIdentifier as string ;

   delay := '0' as integer;
    b as boolean;
  }
  activities {	
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart. delay := timer::timeout('10' as integer);
    test. b := diff(delay,'0' as integer);
    e. throw('unreachable' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart ;  a1<< test; timestart<< test;
               test < a2 when !b;
               test < a2a12 when !b;
               test < a3 when !b;
               test < e when b;
}
}
//  apply unreachable(deadline : '10') => a2;
orchestration cms::witnessReportCaptureExt1a2a {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
  }
  activities {	
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

 a1 < timestart2;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
}
}


//   apply requestVideoSurveillance =>  a2;
orchestration cms::witnessReportCaptureExt1a2a3 {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
   feeder as feederSystem;
   isCovered as boolean;
  }
  activities {	
    covered. isCovered := surveillanceSystem::covers(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
 
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

 a1 < timestart2;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
	       a2<covered;
             covered <getFeeder when isCovered  ;
              getFeeder<feed ;  

   }
}


orchestration cms::witnessReportCaptureExt1a2a3WK {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
   feeder as feederSystem;
   isCovered as boolean;
  }
  activities {	
    covered. isCovered := surveillanceSystem::covers(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
 
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

 test1 < timestart2 when !b1;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
	       a2<covered;
             covered <getFeeder when isCovered  ;
              getFeeder<feed ;  

   }
}


//apply unreachableButContinue(deadline : '10') => a4;
orchestration cms::witnessReportCaptureExt1a2a34a {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
   feeder as feederSystem;
   isCovered as boolean;
delay3 := '0' as integer;
    b3 as boolean;
  }
  activities {	
    covered. isCovered := surveillanceSystem::isCovered(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
 
     a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
    
    timestart3. delay3 := timer::timeout('10' as integer);
    test3. b3 := diff(delay3,'0' as integer);
    o. ci := setNull();
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

  test1 < timestart2 when !b1;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
	       
  a2<covered;
             covered <getFeeder when isCovered  ;
              getFeeder<feed ;  
 
	      a2<timestart3; a3<timestart3;  a4<< test3; timestart3<< test3;
               test3 < a5 when !b3;
               test3 < o when b3;

               o< a5 ;
   }
}


//  apply phoneCompanyInfoDoesntmatch => a2a12;
orchestration cms::witnessReportCaptureExt1a2a34a5a {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
   feeder as feederSystem;
   isCovered as boolean;
delay3 := '0' as integer;
    b3 as boolean;
    match as boolean;
  }
  activities {	
    covered. isCovered := surveillanceSystem::isCovered(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
 
 a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();
    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
    
    timestart3. delay3 := timer::timeout('10' as integer);
    test3. b3 := diff(delay3,'0' as integer);
    o. ci := setNull();

    m. match := cms::match(address,wi); 
    e3. throw('infoDoesNotMatch' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

  test1 < timestart2 when !b1;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
	       
  a2<covered;
             covered <getFeeder when isCovered  ;
              getFeeder<feed ;  
 
	      a2<timestart3; a3<timestart3;  a4<< test3; timestart3<< test3;
               test3 < a5 when !b3;
               test3 < o when b3;

               o< a5 ;

   a2a12  < m; 
    m < e3 when !match; 
   }
}


//  apply onRequestVideoSurveillanceCheckForFakeCrisis =>  a5;
orchestration cms::witnessReportCaptureExt1a2a34a5a5b {
  variables {
    wi as witnessInformation;
    li as locationInformation;
    address as adressInformation;
    exact as boolean;
    ci as crisisInformation;
    cl as checkList;
    cms as crisisManager;
    user as cmsEmployee;
    crisisIdentifier as string ;

    delay1 := '0' as integer;
    b1 as boolean;
    delay2 := '0' as integer;
    b2 as boolean;
   feeder as feederSystem;
   isCovered as boolean;
delay3 := '0' as integer;
    b3 as boolean;
    match as boolean;

    ok as boolean;
  }
  activities {	
    covered. isCovered := surveillanceSystem::isCovered(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
 
    a0.  (user,crisisIdentifier) := receive();
    a1. wi := coordinatorSystem::provideWitnessInformation(user,crisisIdentifier);
    a2. li := coordinatorSystem::provideLocationInformation(user,crisisIdentifier);
    a2a12. address := phoneCompany::getClientInformation(wi);
    a2a3. exact := cms::validateInformation(address,wi);
    a3. cl := cms::computeCheckList(crisisIdentifier);
    a4. ci := coordinatorSystem::provideCrisisInformation(cl,user,crisisIdentifier);
    a5. cms::setCurrentCrisisActive(ci,user,crisisIdentifier);
    a6. reply();

    timestart1. delay1 := timer::timeout('10' as integer);
    test1. b1 := diff(delay1,'0' as integer);
    e1. throw('unreachable' as string);
    timestart2. delay2 := timer::timeout('10'  as integer);
    test2. b2 := diff(delay2,'0' as integer);
    e2. throw('unreachable' as string);
    
    timestart3. delay3 := timer::timeout('10' as integer);
    test3. b3 := diff(delay3,'0' as integer);
    o. ci := setNull();

    m. match := cms::match(address,wi); 
    e3. throw('infoDoesNotMatch' as string);

    test4. ok :=  coordinatorSystem::isFakeCrisis() ;
    e4. throw('fakeCrisis' as string);
  } 
  relations { a0 < a1; a1 < a2; a1<a2a12; a2<a2a3; a1<a3; a3<a4; a2<a4; a4<a5; a5<a6;a2a3<a5 when exact;
a0 < timestart1 ;  a1<< test1; timestart1<< test1;
               test1 < a2 when !b1;
               test1 < a2a12 when !b1;
               test1 < a3 when !b1;
               test1 < e1 when b1;

 test1 < timestart2 when !b1;  a2<< test2; timestart2<< test2;
               test2 < a2a3 when !b2;
               test2 < a4 when !b2;
               test2 < e2 when b2;
	       
  a2<covered;
             covered <getFeeder when isCovered  ;
              getFeeder<feed ;  
 
	      a2<timestart3; a3<timestart3;  a4<< test3; timestart3<< test3;
               test3 < a5 when !b3;
               test3 < o when b3;

               o< a5 ;

   a2a12  < m; 
    m < e3 when !match; 

    test4 < a5 when ok; test4 < e4 when !ok; 
   }
}



// 4.2.2
//Main Success Scenario: 
//System selects an appropriate CMSEmployee based on the mission type, the emergency level, location and 
//requested expertise. 
//TODO/Perso : We have to take care of the following requirements in an evolution.
// In very urgent cases, steps 1 and 2 can be performed for several CMSEmployees concur- 
//rently, until one of the contacted employees accepts the mission. 
//1. System sends CMSEmployee mission information. 
//2. CMSEmployee informs System that he accepts the mission. 
//Use case ends in success.
orchestration cms::assignInternalResource {
  variables {
    m as mission;
    accept as boolean;
    cmsEmployee as employee;
  }
  activities {	
    a0. m := receive();
    a1. cmsEmployee := cms::selectEmployee(m);
    a2. accept := cmsEmployee::askFor(m);
    a6. reply(cmsEmployee);

  } 
  relations { a0 < a1; a1 < a2; a2<a6 ; } 
}

  */
// 4.2.2
/* 4.2.4 Request External Resource */
/* Use Case 4: Request External Resource */
/* Scope: Car Crash Crisis Management System */
/* Primary Actor: Coordinator */
/* Secondary Actor: ExternalResourceSystem (ERS) */
/* Intention: The System requests a mission from an external resource, such as a fire station, police station or external */
/* ambulance service. */
/* Main Success Scenario: */
/* 1. System sends mission request to ERS, along with mission-specific information1. */
/* 2. ERS informs System that request can be processed. */
/* Use case ends in success. */
//Perso : Following extensions are managed by the return allocated ressource or an error
//2a. ERS notifies System that it partially approves request for resources. Use case ends in degraded success.
//2a. ERS notifies System that it partially approves request for resources. Use case ends in degraded success.

/*
orchestration cms::assignExternalResource {
  variables {
    m as mission;
    eS as externalRessource;
    allocatedRessource as externalRessource;
  }
  activities {	
    a0. m := receive();
    a1. allocatedRessource := eRS::request(m);
    a2. reply(allocatedRessource);

  } 
  relations { a0 < a1; a1 < a2 ; } 
}


//4.2.7 part 3
orchestration cms::setNewVictimInformation {
  variables {
    info as information;
    hostpitalInfo as information;
  }
  activities {	
    a0. info := receive();
   //System requests victim’s medical history information "from all"connected HospitalResourceSystems. 
   a1. hostpitalInfo := hospitalResourceSystems::getInfo(info);
   a2. reply(hostpitalInfo);
  } 
  relations { a0 < a1; a1 < a2; } 
 } 
*/


//-----------------------------------------------


//4.2.5
//n'importequoi a revoir totalement
/* Use Case 6: Execute SuperObserver Mission */
/* Scope: Car Crash Crisis Management System */
/* Primary Actor: SuperObserver */
/* Secondary Actor: None */
/* Intention: The intention of the SuperObserver is to observe the situation at the crisis site to be able to order */
/* appropriate missions. */
/* 19 */
/* Main Success Scenario: */
/* SuperObserver is at the crisis location. */
/* 1. System sends a crisis-specific checklist to SuperObserver. */
/* 2. SuperObserver feeds System with crisis information. */
/* 3. System suggests crisis-specific missions to SuperObserver. */
/* Steps 4-8 is repeated as many times as needed. */
/* 4. SuperObserver notifies System of the type of mission he wants to create. */
/* 5. System sends a mission-specific information request to SuperObserver. */
/* 6. SuperObserver sends mission-specific information1 to System. */
/* 7. System acknowledges the mission creation to SuperObserver. */
/* 8. System informs SuperObserver that mission was completed successfully. */
/* 9. SuperObserver judges that his presence is no longer needed at the crisis location. */
/* Use case ends in success. */
/*
orchestration superObserver::executeMission {
  variables {
    m as mission;
    mission* as mission;
    cL as checkList;
    ci as crisisInformation;
  }
  activities {	
    a0. m := receive();
    a1. cL := cms::getCrisisSpecificCheckList(m);
    a2. ci := superObserver::feed(cL);
    a2c. cms::setNewCrisisInformation(ci);
    // end set
    //System suggests crisis-speciﬁc missions to SuperObserver
    a3. mission* := cms::missionsToDo();
    a3a. superObserver::suggest(mission*);
   //SuperObserver notiﬁes System of the type of mission he wants to create...step 4 to 8
    a89. superObserver::manageMissions();
   //SuperObserver judges that his presence is no longer needed at the crisis location. 
    a9. ressourceManager::setExecutionEnd(m,superObserver);
  } 
  relations { a0 < a1; a1 < a2; a2<a2c; a2c<a3;a3<a89;a89<a9; } 
} 

//4. SuperObserver notifies System of the type of mission he wants to create.
//5. System sends a mission-specific information request to SuperObserver.
//6. SuperObserver sends mission-specific information1 to System.
//7. System acknowledges the mission creation to SuperObserver.
//8. System informs SuperObserver that mission was completed successfully
//Perso : il faudrait factoriser le create mission....
//Je hais cette orchestration...n'importe quoi....
orchestration superObserver::manageMissions {
  variables {
    mission as mission;
    cL as checkList;
    ci as crisisInformation;
    again as boolean;
  }
  activities {	
    a0.  receive();
    a4. mission := whichMission();
    a5. request := cms::getMissionSpecificRequest(mission);
    a6. mission := superObserver::fillRequest(request);
    a7. mission := cms::createMission(mission);
    a8. cms::manageMission(mission);
    stop. again := askForMissionCreation();
    loop. superObserver::manageMissions();
    end. reply();

  } 
  relations { a0 < a4; a4 < a5; a5<a6; a6<a7;a7<a8;a8<stop;stop<loop when again; stop<end when !again; } 
}


//4.2.7 Execute Rescue Mission
//Use Case 7: Execute Rescue Mission
//Scope: Car Crash Crisis Management System
//Primary Actor: FirstAidWorker
//Secondary Actor: HospitalRS
//Intention: The intention of the FirstAidWorker is to accept and then execute a rescue mission that involves transporting a victim to the most appropriate hospital.
//Main Success Scenario:
//FirstAidWorker is at the crisis location.
//1. FirstAidWorker transmits injury information of victim to System.
//Steps 2 and 3 are optional.
//2. FirstAidWorker determines victim’s identity and communicates it to System.
//3. System requests victim’s medical history information from all connected HospitalResourceSystems.
//FirstAidWorker administers first aid procedures to victim.
//4. System instructs FirstAidWorker to bring the victim to the most appropriate hospital.
//5. FirstAidWorker notifies System that he is leaving the crisis site.
//6. FirstAidWorker notifies System that he has dropped off the victim at the hospital.
//7. FirstAidWorker informs System that he has completed his mission.
//Use case ends in success.
//Perso : probablement ajouter pkys de setNewCrisisInformation
//Perso : verfier les types... ca ne doit pas bien aller

//Distinguer IHM et Service????
orchestration workerSystem::executeMission {
  variables {
    m as mission;
    mission* as mission;
    hospital as string;
    q as question;
    ci as crisisInformation;
    info as information;
    b as boolean;
    medicalHistory as information;
  }
  activities {	
    a0. m := receive();
    //FirstAidWorker transmits injury information of victim to System. 
    a1a. ci := workerSystem::getVictimInjuryInformation();
    a1b. cms::setNewCrisisInformation(ci);
    //2. FirstAidWorker determines victim’s identity and communicates it to System. 
    a2a.  (b,info) := workerSystem::getVictimInformation();
    a2b. cms::setNewVictimInformation(info);
    //3. System requests victim’s medical history information from all connected HospitalResourceSystems.
    a3. medicalHistory := cms::getMedicalHistoryInformation(info);
    a4. hospital :=  cms::hospitalToGo(ci);
    a4a. workerSystem::setHospitalToGo(hospital);
    a5. workerSystem::confirmLeaving();
    a6. workerSystem::confirmDropping();
    a7. workerSystem::confirmMissionCompleted();
    a8. reply();
  } 
  relations { a0 < a1a; a1a < a1b; a0<a2a; a2a<a2b when b ;a2b<a3;
    a1b<a4;a4<a4a;a4a<a5; a5< a6; a6 < a7; a7<a8; } 
}
*/
