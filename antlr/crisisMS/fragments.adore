
//------------
fragment notify <observer, what, who> {
  variables  {}
  activities {
    h.  hook() ;
    notify. observer::notify(what,who);
 }
  relations  { ^ < h;  h < $; h<notify;  }
}


//--------------
//a priori pbme de syntaxe avec throw...
//a priori pbme de syntaxe avec error que je veux comme une variable...
fragment halt <error> { 
  variables  {
              b as boolean; }
  activities {
    h. b := hook();
    t. throw(error);
  }
  relations  { ^ < h; h<$ when b ;h < t when !b; } 
}

//----------------
//a priori pbme de syntaxe avec error que je veux comme une variable...
fragment stop <error> { 
  variables  { }
  activities {
    h. hook();
    o. reply();
  }
  relations  { ^ < h;  h<$ ; fail(h,'error') < o ; } 
}

//------------------
//a priori pbme de syntaxe avec error que je veux comme une variable...
//Bizarre
fragment continue <error> { 
  variables  { }
  activities {
    h. hook();
  }
 relations  { ^ < h; h<$;  fail(h,'error')<$ ; } 
}

//warning : verifier les types
fragment continueWithNull <error> { 
  variables  {
  res as info; }
  activities {
    h. res := hook();
    o. res := setNull();
  }
  relations  { ^ < h; h<$;  fail(h,'error')<o; o< $ ; } 
}

//------------------
//extension 1a de 4.2.1
//1a. Coordinator is not logged in. 
//1a.1 Coordinator authenticates with System (UC 10). 
//1a.2 Use case continues with step 1.
//a priori pbme de syntaxe avec throw...
//Perso : ?? verifier cette écriture

fragment log <authenticationService,logger>{
  variables  {
              isLogged as boolean ;
              a as boolean; }
  activities {
    logTest. isLogged := authenticationService::isLogged(logger);
    h.  hook() ;
    authent. a := authenticationService::authenticates(logger); //Uc 10???
    h1. hook() ;
    e. throw('accessDenied' as string);}
  relations  { ^ < logTest; logTest<h when isLogged ; h < $; 
              logTest < authent when !isLogged; 
              authent<h1 when a;  h1<$;
	      authent<e when !a;  }
}





//extension 5a de 4.2.1
//5a. External resource is not available after step 5. 
//5a.1 Use case continues in parallel with step 2. 
//bizarre elle est la meme que la 4a mais en reduction
//Il faudrait un delegate qui prenne nop
//Je ne retourne pas au step 2 .... 
//c'est au cms de decider en fonction de l'info obtenu
//Comment faire???
//Je rajouterai bien un signalement de pbme...
fragment ressourceAvailabilityDegrated <ressource>{ 
  variables  {
              b as boolean;
 	      r as ressource ;
              i as crisisInformation; }
  activities {
    availabilityTest. b :=  ressourceManager::isAvailable(ressource);
    h.  hook() ; 
    conta. i := new(crisisInformation, 'ressourceUnavailable' as string,r);
    contb. cms::setNewCrisisInformation(i);
  }
  relations  { ^ < availabilityTest; availabilityTest<h when b ; h < $; 
    availabilityTest < conta when !b; conta<contb;
  }
}




//------------------
//4a. Internal resource is not available after step 4. 
//4a.1 System requests an external resource instead (i.e., use case continues in parallel with step 5).
//Il faudrait un delegate qui prenne : ask et ass
fragment ressourceAvailability <ressource,mission> { 
  variables  {
              b as boolean;
 	      r as ressource ; }
  activities {
    availabilityTest. b :=  ressourceManager::isAvailable(ressource);
    h.  hook() ; 
    ask. r := ressourceManager::getCorrespondingExternalRessource(ressource);
    ass. cms::assignExternalRessources(r,mission);
  }
  relations  { ^ < availabilityTest; availabilityTest<h when b ; h < $; 
              availabilityTest < ask when !b; ask<ass ;  ass<$;
  }
}



//------------------
//une constante de temps?
//pbme dans un lien faible... je rajoute l'ordre.. l'aurions nous bien detecté?

//a priori un pbme de constante avec l'affecation

fragment unreachable <deadline> { 
  variables  {
  delay := '0' as integer;
    b as boolean;
  }
  activities {
    //a0. timeout := '0' as integer;
    timestart. delay := timer::timeout(deadline);
    h.  hook() ; 
    test. b := diff(delay,'0' as integer);
    e. throw('unreachable' as string);
  }
  relations  { ^ < timestart; ^< h ;  h<< test; timestart<< test;
               test < $ when !b;
               test < e when b; }
}


fragment unreachableButContinue <deadline> { 
  variables  {
    delay := '0' as integer;
    b as boolean;
    res as info;
  }
  activities {
    //a0. timeout := '0' as integer;
    timestart. delay := timer::timeout(deadline);
    h.  res := hook();
    test. b := diff(delay,'0' as integer);
    o. res := setNull();
    
  }
  relations  { ^ < timestart; ^< h ;  h<< test; timestart<< test;
               test < $ when !b;
               test < o when b; 
               o < $; }
}



//------------------
//From 4.2.3 Assign Internal Resource
//1b. CMSEmployee is unavailable (( or unresponsive. is detected by another fragment)
//1b.1 System selects the next appropriate CMSEmployee.
//1b.2 Use case continues at step 1.
//1b.1a No other CMSEmployee is available. Use case ends in failure.
//Perso :  I leave the propagation of the error  raised by selectEmployee
//Perso : comment dire si faux ou catch autrement...
//Perso : des delegate....
//CMSEmployee informs System that he cannot accept the mission.
//2a.1 System selects the next appropriate CMSEmployee.
//2a.2 Use case continues at step 1.
//2a.2a No other CMSEmployee is available. Use case ends in failure.
//Perso : The both extensions are designed together.

fragment unavailable <employee> { 
  variables  {cmsEmployee as employee;
              m as mission;
              b as boolean;
 	       }
  activities {
    h.  b := hook(m) ; 
    a1. cms::unavailable4(m,employee); //To remember the unavailability
    a2. cmsEmployee := cms::assignInternalResource(m);
    a3. reply(cmsEmployee);
    a1catch. cms::unavailable4(m,employee); //To remember the unavailability
    a2catch. cmsEmployee := cms::assignInternalResource(m);
    a3catch. reply(cmsEmployee);
  }
  relations  { ^ < h; h<$ when b;
    h< a1 when !b; a1<a2; a2<a3;
    fail(h)< a1catch;  a1catch<a2catch; a2catch<a3catch; }
}

//------------------

//6a. System determines that the crisis location is unreachable by standard transportation means, but reachable by helicopter.
//6a.1 System informs the Coordinator about the problem.
//6a.2 Coordinator instructs System to execute a helicopter transport mission (UC 09).
//apriori un pbme ....
fragment reachableByHelicopter { 
  variables  {i as crisisInformation;
              m as mission ;
              unreachable as boolean;
 	      r as ressource ;
	      reachableByHelicopter as boolean;}
  activities {
    h. i := hook();
    u. unreachable := cms::locationUnreachable(i);
    helicop. reachableByHelicopter := cms::reachableByHelicopter(i);
    a1. coordinatorSystem::notify('locationReachableByHelicopter' as string,i);
    a2. m := cms::createHelicopterTransportMission(i);
    a4. ir := getRessource(m);
    a5. cms::manageRessource(ir,m);
  }
  relations  { ^ < h; h<$; h<u; u< helicop when unreachable ; 
    helicop < a1 when reachableByHelicopter;
    a1< a2 ; a2< a4;  a4 <a5; } 
}


/* fragment cession <error> {  */
/*   variables  {s as service; */
/*               m as mission ; */
/*               b as boolean; */
/*  	      r as ressource ; } */
/*   activities { */
/*     h. b := hook(); */
/*     t. throw(error); */
/*   } */
/*   relations  { ^ < h; h<$ when b ;h < t when !b; }  */
/* } */





//6b  du  4.2.1 non faite...
//pour plein de raisons
//que se passe-til si j'ai recu l'alerte et est lancé un helicopter
//avant de recevoir l'avsi
//je n'ai pas defini le secnario du worker etc...
//Il me manque des evenements pour la gerer... 
//J'ai vraiment des pbmes entre un enonces par evenement et une programmation synchrone....

//6c  du  4.2.1 non faite...
//bizarre c'est peut etre la mienne en fait comme je ne savais pas
//detecter le cote unreachable.... a revoir probablement...

//7a  du  4.2.1 
//pas assez claire...
//cette approche ne correspond pas bien je m'emmelle encore parce que
//je pense en local 
//7a. One or more further missions are required in step 6. 
//7a.1 Use case continues in parallel with step 2. 
/* fragment otherMissionRequired {  */
/*   variables  {s as service; */
/*               m as mission ; */
/*               b as boolean; */
/*  	      r as ressource ; } */
/*   activities { */
/*     test. b := cms::otherMissionRequired(); */
/*     a0. hook; */
/*     a1. m :=  cms::missionToDo(); */
/*     a2. cms::manageRessource(m); */
/*   } */
/*   relations  { ^ < test; ^ < a0;a0<$; */
/*   	      a1< a2 ; }  */
/* } */





//From 4.2.2
//In parallel to steps 3-4, if the crisis location is covered by camera surveillance: 
//3a.1 System requests video feed from SurveillanceSystem. 
//3a.2 SurveillanceSystem starts sending video feed to System. 
//3a.3 System starts displaying video feed for Coordinator. 

fragment requestVideoSurveillance { 
  variables  {
   feeder as feederSystem;
   li as locationInformation;
   isCovered as boolean; }
  activities {
    h. li := hook();
    covered. isCovered := surveillanceSystem::isCovered(li);
    getFeeder. feeder := surveillanceSystem::getVideo();
    feed. coordinatorSystem::setVideo(feeder);
  }
  relations  { ^ < h; h < $;
    h<covered; covered <getFeeder when isCovered  ;
              getFeeder<feed ;  } 
}

//From 4.2.2
//5a. PhoneCompany information does not match information received from Witness.
//5a.1 The base use case is terminated. 

fragment phoneCompanyInfoDoesntmatch { 
  variables  {
   address as adressInformation;
   wi as witnessInformation;
   match as boolean; }
  activities {
    h. address := hook(wi);
    m. match := cms::match(address,wi); 
    e. throw('infoDoesNotMatch' as string);
  }
  relations  { ^ < h; h < m; 
    m < $ when match; m < e when !match; 
  } 
}
//5b. Camera vision of the location is perfect, but Coordinator cannot conﬁrm the situation that the witness describes or the Coordinator determines that the witness is calling in a fake crisis. 
//5b.1 The base use case is terminated. 


fragment onRequestVideoSurveillanceCheckForFakeCrisis { 
//require requestVideoSurveillance to make sense
  variables  {
    ok as boolean;
}
  activities {
    test. ok :=  coordinatorSystem::isFakeCrisis() ;
    h. hook();
    e. throw('fakeCrisis' as string);
   
  }
  relations  { ^ < h; h<$; test< h when ok; test< e when !ok;  } 
}

//From 4.2.3 Assign Internal Resource
//1b. CMSEmployee is unavailable or unresponsive.
//1b.1 System selects the next appropriate CMSEmployee.
//1b.2 Use case continues at step 1.
//1b.1a No other CMSEmployee is available. Use case ends in failure.

fragment cmsEmployeeUnresponsive { 
//require requestVideoSurveillance to make sense
  variables  {}
  activities {
    h. hook();
    a1. ok :=  coordinatorSystem::isFakeCrisis() ;
  }
  relations  { ^ < h; h < a1; a1< $ when ok;  } 
}




//from 4.2.7
//4a. HospitalResourceSystem transmits victim’s medical history information to System.
//4a.1 System notifies FirstAidWorker of medical history of the victim relevant to his injury.
//4a.2 Use case continues at step 4.

fragment medicalHistoryAvailable { 
  variables  {
mh as information;
relevantInformation as information;}
  activities {
    h. mh := hook();
    a1. relevantInformation :=  cms::filterInformation(mh);
    a2. workerSystem::setMedicalHistory(relevantInformation); 
  }
  relations  { ^ < h; h < a1; a1<a2; a2< $;   } 
}







