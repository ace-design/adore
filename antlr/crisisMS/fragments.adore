
//------------
fragment notify <observer, what, who> {
  variables  {}
  activities {
    h.  hook() ;
    notify. observer::notify(what,who);
  relations  { ^ < h;  h < $; h<notify;  }
}


//--------------
fragment cession <error> { 
  variables  {s as service;
              m as mission ;
              b as boolean;
 	      r as ressource ; }
  activities {
    h. b := hook;
    t. throw error;
  }
  relations  { ^ < h; h<$ when b ;h < t when !b; } 
}

//----------------
fragment stop <error> { 
  variables  { }
  activities {
    h. hook;
    o. reply();
  }
  relations  { ^ < h;  h<$ ; fail(h,error) < o ; } 
}

//------------------
//Bizarre
fragment continue <error> { 
  variables  { }
  activities {
    h) hook;
  }
 relations  { ^ < h; h<$;  fail(h,error)<$ ; } 
}

//------------------
//extension 1a de 4.2.1
//1a. Coordinator is not logged in. 
//1a.1 Coordinator authenticates with System (UC 10). 
//1a.2 Use case continues with step 1.

//Perso : ?? verifier cette écriture

fragment log <authenticationService,logger>{
  variables  {
              isLogged as boolean ;
              a as boolean }
  activities {
    logTest. isLogged := authenticationService::isLogged(logger);
    h.  hook() ;
    authent. a := authenticationService::authenticates(logger); //Uc 10???
    h1. hook() 
    e. throw accessDenied;}
  relations  { ^ < logTest; logTest<h when isLogged ; h < $; 
              logTest < authent when !isLogged; 
              authent<h1 when a;  h1<$;
	      authent<e when !a;  }
}





//extension 5a de 4.2.1
//5a. External resource is not available after step 5. 
//5a.1 Use case continues in parallel with step 2. 
//bizarre elle est la meme que la 4a mais en reduction
//Il faudrait un delegate qui prenne nop
fragment ressourceAvailabilityDegrated <ressource>{ 
  variables  {
              b as boolean;
 	      r as ressource ; }
  activities {
    availabilityTest. b :=  ressourceManager::isAvailable(ressource);
    h.  hook() ; 
    cont. nop;
  }
  relations  { ^ < availabilityTest; availabilityTest<h when b ; h < $; 
              availabilityTest < nop when !b; nop<$;
  }
}


//------------------
//4a. Internal resource is not available after step 4. 
//4a.1 System requests an external resource instead (i.e., use case continues in parallel with step 5).
//Il faudrait un delegate qui prenne : ask et ass
fragment ressourceAvailability <ressource,mission> { 
  variables  {
              b as boolean;
 	      r as ressource ; }
  activities {
    availabilityTest) b :=  ressourceManager::isAvailable(ressource);
    h.  hook() ; 
    ask. r := ressourceManager::getCorrespondingExternalRessource(ressource);
    ass. cms::assignExternalRessources(r,mission);
  }
  relations  { ^ < availabilityTest; availabilityTest<h when b ; h < $; 
              availabilityTest < ask when !b; ask<ass ;  ass<$;
  }
}



//------------------
//une constante de temps?
//pbme dans un lien faible... je rajoute l'ordre.. l'aurions nous bien detecté?
fragment unreachable <deadline> { 
  variables  {timeout as integer;
             
              b as boolean;
 	       }
  activities {
    a0. timeout := '0' as integer;
    timestart. timeout := Timer::timeout(deadline);
    h.  hook() ; 
    test. b := diff(timeout,'0' as integer);
    e. throw unreachable;
  }
  relations  { ^ < a0; a0< timestart; ^< h ;  h<< test; timestart<< test; a0 < test;
               test < $ when !b;
               test < e when b; }
}

//------------------
//From 4.2.3 Assign Internal Resource
//1b. CMSEmployee is unavailable (( or unresponsive. is detected by another fragment)
//1b.1 System selects the next appropriate CMSEmployee.
//1b.2 Use case continues at step 1.
//1b.1a No other CMSEmployee is available. Use case ends in failure.
//Perso :  I leave the propagation of the error  raised by selectEmployee
//Perso : comment dire si faux ou catch autrement...
//Perso : des delegate....
//CMSEmployee informs System that he cannot accept the mission.
//2a.1 System selects the next appropriate CMSEmployee.
//2a.2 Use case continues at step 1.
//2a.2a No other CMSEmployee is available. Use case ends in failure.
//Perso : The both extensions are designed together.

fragment unavailable <employee> { 
  variables  {cmsEmployee as employee;
              m as mission;
              b as boolean;
 	       }
  activities {
    h.  b := hook(m) ; 
    a1. cms::unavailable4(m,employee); //To remember the unavailability
    a2. cmsEmployee := cms::assignInternalResource(m);
    a3. reply(cmsEmployee);
    a1catch. cms::unavailable4(m,employee); //To remember the unavailability
    a2catch. cmsEmployee := cms::assignInternalResource(m);
    a3catch. reply(cmsEmployee);
  }
  relations  { ^ < h; h<$ when b;
    h< a1 when !b; a1<a2; a2<a3;
    fail(h)< a1catch;  a1catch<a2catch; a2catch<a3catch; }
}

//------------------


fragment reachByHelicopter { 
  variables  {s as service;
              m as mission ;
              b as boolean;
 	      r as ressource ; }
  activities {
    a0a. catch unreachable; //on hook catch unreachable 
    a0b. hook;
    a1. coordinatorSystem::notify('locationUnreachable', r, m);
    a2. m := cms::createHelicopterTransportMission(m);
    a3. call; //pour le distinguer du call...
    a4. r := getRessource(m);
    a5. cms::manageRessource(ir,m);
  }
  relations  { ^ < a0a; ^ < a0b; h<<$;a5<<$;
  	      a0a< a1; a1< a2 ; a2< a3; a3 < a4; a4 <a5; } 
}


fragment cession <error> { 
  variables  {s as service;
              m as mission ;
              b as boolean;
 	      r as ressource ; }
  activities {
    h. b := hook;
    t. throw error;
  }
  relations  { ^ < h; h<$ when b ;h < t when !b; } 
}





//6b  du  4.2.1 non faite...
//pour plein de raisons
//que se passe-til si j'ai recu l'alerte et est lancé un helicopter
//avant de recevoir l'avsi
//je n'ai pas defini le secnario du worker etc...

//6c  du  4.2.1 non faite...
//bizarre c'est peut etre la mienne en fait comme je ne savais pas
//detecter le cote unreachable.... a revoir probablement...

//7a  du  4.2.1 
//pas assez claire...
//cette approche ne correspond pas bien je m'emmelle encore parce que
//je pense en local 
//7a. One or more further missions are required in step 6. 
//7a.1 Use case continues in parallel with step 2. 
fragment otherMissionRequired { 
  variables  {s as service;
              m as mission ;
              b as boolean;
 	      r as ressource ; }
  activities {
    test. b := cms::otherMissionRequired();
    a0. hook;
    a1. m :=  cms::missionToDo();
    a2. cms::manageRessource(m);
  }
  relations  { ^ < test; ^ < a0;a0<$;
  	      a1< a2 ; } 
}






//1a,2a. The call is disconnected. The base use case terminates. 
//In parallel to steps 3-4, if the crisis location is covered by camera surveillance: 
//3a.1 System requests video feed from SurveillanceSystem. 
//3a.2 SurveillanceSystem starts sending video feed to System. 
//3a.3 System starts displaying video feed for Coordinator. 

fragment requestVideoSurveillance { 
  variables  {}
  activities {
    h. hook;
    a1. feeder := SurveillanceSystem::getVideo();
    a2. coordinatorSystem::setVideo(feeder);
  }
  relations  { ^ < h; h < $; 
               h<a1 on failure unreachable;
               a2<<$;
  	       a1< a2 ;  } 
}


//5b. Camera vision of the location is perfect, but Coordinator cannot conﬁrm the situation that the witness describes or the Coordinator determines that the witness is calling in a fake crisis. 
//5b.1 The base use case is terminated. 

//Perso: Definition liée à une autre evolution....


fragment onRequestVideoSurveillanceCheckForFakeCrisis { 
//require requestVideoSurveillance to make sense
  variables  {}
  activities {
    h. hook;
    a1. ok :=  coordinatorSystem::isFakeCrisis() 
  }
  relations  { ^ < h; h < a1; a1< $ when ok;  } 
}

//From 4.2.3 Assign Internal Resource
//1b. CMSEmployee is unavailable or unresponsive.
//1b.1 System selects the next appropriate CMSEmployee.
//1b.2 Use case continues at step 1.
//1b.1a No other CMSEmployee is available. Use case ends in failure.

fragment CMSEmployeeUnresponsive { 
//require requestVideoSurveillance to make sense
  variables  {}
  activities {
    h. hook;
    a1. ok :=  coordinatorSystem::isFakeCrisis() 
  }
  relations  { ^ < h; h < a1; a1< $ when ok;  } 
}


//besoin d'en mettre sur plusieurs... elles sont liées entre elles... 
// comment capturer l'info????

merge cms::resolve { 
 //apply log => a1;
 //apply ressourceAvailability => a4a2;
 //apply ressourceAvailabilityDegrated => a5a2;
 apply reachByHelicopter => a4a3;
 apply reachByHelicopter => a5a3;

}

merge cms::manageRessource  { 
 apply unreachable => a1;
 apply otherMissionRequired => a1;
}





merge cms::witnessReportCapture  { 
 apply unreachable => a1;a2;
}

