/*
1) Remarks : "Complexity"
To Deal with such a complexity we really need separation of concerns.
But to "try" to deal with consistency we also need to build the resulting global system and to visualize it. The main interests of our approach are to automatically build the final result, to visualize it, to check in an automatic way for inconsistency, to memorize solutions given by final user as reusable knowledge. So the designer will be able to retract fragments, add new ones, recompute the result without repeating solutions he has already given to the system.


2) Error : "signature conformance"
We are expecting from an orchestration to respect the signature. So all the reply activities should return a variable of the same type.

In this example, when a "missionFailed" we don't reply a report as it was not asked in the requirement document. So the resulting orchestration is false. An error is raised. Adding "null" as parameter of reply in this report is a way to solve this error.


3) "Limites of our approach" : Redundant calls and shared variables beetween several fragments

In this example, we use twice the same fragment "lost". One optimisation could be to share the variable super and the activity    "a2. super := cms::getSuperObserver(c);" as they apply on the same variables.

We don't do that. Overlapping activities have been studied in ... Such a process could be applied on the resulting orchestration to optimise it. But the process is complex as factorizing activities can introduce unexpected precedences between activities. 

JE COMPREND PAS CE QUI SUIT : 
=> 
@mi: 
il me parait plus interessant de tisser un fragment qui va nous donner 'super' 
au départ si c'est VRAIMENT ce qu'on veut, et la réutiliser ailleurs au besoin.
Et bing, des variables VOLONTAIREMENT partagée entre fragment ... et paf, ca 
fait des chocapics.



Result from : 

composition cms::handleAWorker {
  apply useHelicopter(m: 'm')               => a6; // Ext 6a.
  apply lostContact(action: 'requestForArrival', c : 'crisis') => a6; // Ext 6b.
  apply timeout(delay: 'm.delay',action: 'updateLocation')  => a6; // Ext 6c.
  apply reHandleOnChange(cxt: 'm', crisis: 'crisis')         => a7; // Ext 7a.
  apply missionFailed()                     => a7; // Ext 7b.
  apply lostContact(action: 'requestForDeparture', c : 'crisis') => a8; //Ext 8a.
  // Ext 8b. can't be performed without a huge set of changes in the workflow
  apply missingReport                                       => a11; // Ext 11a. 
}

*/

orchestration cms::handleAWorker {
  variables {
    crisis as crisisIdentifier;
    w as worker; r as report; m as mission; coord as cmsEmployee;

    uH_r as boolean;    uH_ok as boolean;

    lC0_super as cmsEmployee;

    const t0_true := 'true' as boolean;
    const t0_false := 'false' as boolean;    
    t0_c as boolean; t0_expired as boolean;
    t0_r as report;

    lC1_super as cmsEmployee;

    rHOC_mustWait as boolean; rHOC_c as boolean;


  }
  activities {
    rcv. (crisis,w,m,coord) := receive();
    a100. ui::actListener(w, crisis, 'info' as string);
    a101. ui::actListener(w, m, 'info' as string);
    a6. msgBus::wait4Msg('info' as string, 'arrived' as string, w);
    a7. cms::executeMission(m,w,crisis,coord);
    a8. msgBus::wait4Msg('info' as string, 'leaving' as string, w);
    a11. r := ui::askForReport(w);
    rpl. reply(r);
    a100bis. ui::stopListener(w,crisis, 'info' as string);
    a101bis. ui::stopListener(w, m, 'info' as string);

    uH_a1. uH_r := cms::helicopterRequired(m);
    uH_a2. uH_ok := ui::ask4Helicopter(coord,w,m);
    uH_a3. cms::transportByHelicopter(w,m.loc);

    lC0_a1. msg::wait4Msg('info' as string, 'lost' as string, w);
    lC0_a2. lC0_super := cms::getSuperObserver(crisis);
    lC0_a3. ui::requestForArrival(lC0_super,w);

    t0_a0. t0_expired := t0_false;
    t0_a1. stopwatch::sleep(m.delay);
    t0_a2. t0_expired := t0_true;
    t0_a3. t0_c := isTrue(t0_expired);
    t0_a4. ui::updateLocation(w);
    t0_a5. t0_r := cms::handleAWorker(crisis,w,m,coord);
    t0_a6. reply(t0_r);

    mF_a1. msgBus::send('status' as string, 'failed' as string, m);
    mF_a2. cms::handleCrisis(crisis);
    mF_a3. reply('null' as report);

    lC1_a1. msg::wait4Msg('info' as string, 'lost' as string, w);
    lC1_a2. lC1_super := cms::getSuperObserver(crisis);
    lC1_a3. ui::requestForDeparture(lC1_super,w);

    mR_a1. r := id('null' as report);


    rHOC_a0. rHOC_mustWait := id('false' as boolean);
    rHOC_a1. msgBus::wait4msg('status' as string, 'change' as string, m);
    rHOC_a2. rHOC_mustWait := id('true' as boolean);
    rHOC_t. rHOC_c := isTrue(rHOC_mustWait);
    rHOC_a3. cms::handleACrisis(crisis);
    rHOC_a4. nop();

  }
  relations {
    rcv < a100; rcv < a101; 
    //a6 < a7; 
    // a7 < a8; 
     //a8 < a11 ; 
     //a11 < rpl;
    //a8 < a100bis; a8 < a101bis;

    a100 < uH_a1; a101 < uH_a1; uH_a1 < a6 when ! uH_r;  uH_a1 < uH_a2 when uH_r;
    uH_a2 < uH_a3 when uH_ok; uH_a2 < a6  when !uH_ok; uH_a3 < a6; 


    a100 < lC0_a1; a101 < lC0_a1; a6 << a7; lC0_a1 < lC0_a2; lC0_a2 < lC0_a3; lC0_a3 << a7;

    a100 < t0_a0; a101 < t0_a0; 
    t0_a0 < a6; t0_a0 < t0_a1; t0_a1 < t0_a2; a6 << t0_a3; t0_a2 << t0_a3;
    t0_a3 < t0_a4 when t0_c; t0_a4 < t0_a5; t0_a5 < t0_a6; t0_a3 < a7 when !t0_c;

    fail(a7,'failed') < mF_a1; mF_a1 < mF_a2; mF_a2 < mF_a3;

    a7 < lC1_a1; a8<<a11; a8 <<a100bis; a8 <<a101bis ; 
    lC1_a1 < lC1_a2; lC1_a2 < lC1_a3; 
    lC1_a3 << a11;lC1_a3 << a100bis ; lC1_a3 << a101bis; 

   fail(a11) < mR_a1; a11 << rpl; mR_a1 << rpl;


    a7 << rHOC_t; rHOC_t < a8 when !rHOC_c; a6< rHOC_a0; 
    rHOC_a0 < rHOC_a1; rHOC_a1 < rHOC_a2; rHOC_a2 << rHOC_t; 
    rHOC_a1 < rHOC_a3; rHOC_a3 < rHOC_a4; rHOC_t < rHOC_a4 when rHOC_c; 
    rHOC_a4 < a8;
  }
}

